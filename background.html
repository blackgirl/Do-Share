<script type="text/javascript" src="/libs/jquery-1.7.1.min.js"></script>
<script type="text/javascript" src="/jsapi/jsapi_helper.js"></script>
<script type="text/javascript" src="/jsapi/jsapi_abstract_database.js"></script>
<script type="text/javascript" src="/jsapi/jsapi_database.js"></script>
<script type="text/javascript" src="/jsapi/jsapi_for_google_plus.js"></script>

<script src="/browser_action_controller.js"></script>

<script src="IDBWrap/wrap.js"></script>
<script src="/Sched5.js"></script>
<script>

var ACTION_UPDATE_INTERVAL = 333;
var INIT_REPEAT_INTERVAL = 3 * 60000;

var dbInit = false;
var dbInitCounter = 2;
function dbInitCallback(ok) {
  if (ok) {
    if (--dbInitCounter == 0) {
      dbInit = true;
    }
  }
}

// Set up the API
var plus = new GooglePlusAPI();
window.setTimeout(function(){
  plus.init(function() {
    plus.refreshCircles(c, true);
  }), 1;
});

window.setInterval(function() {
  plus.init(function(){});
}, INIT_REPEAT_INTERVAL);

var lastUpdate = -1;
function update() {
  lastUpdate = new Date().getTime();
}

function c(e){console.log(e)}

var db = new IDBWrap("nightwatchDb", "writeTimeStamp");
db.init(dbInitCallback);

var s = new Sched5("nightwatch", "writeTimeStamp", publishScheduled, c);
s.init(dbInitCallback);

var actionController = new BrowserActionController();

var previousTotal;
var previousLogicBits;
function updateAction(numDrafts, numScheduled) {
  var hasScheduled = (numScheduled > 0);

  var total = numDrafts + numScheduled;
  var logicBits = !!total + hasScheduled << 1;
  if (total == previousTotal && logicBits == previousLogicBits) {
    return;
  }
  previousTotal = total;
  previousLogicBits = logicBits;

  var badgeText = "Do Share - ";
  function s(count) {
    if (count == 1) {
      return '';
    }
    return 's';
  }
  if (total == 0) {
    badgeText += "Ready";
  } else if (hasScheduled) {
    badgeText += numScheduled + " post" + s(numScheduled) + " scheduled, " + numDrafts + " draft" + s(numDrafts) + " saved";
  } else {
    badgeText += numDrafts + " draft" + s(numDrafts) + " saved";
  }
  actionController.drawBadgeIcon(total, badgeText, hasScheduled);
}

(function refreshAction() {
  if (dbInit) {
    var waiting = 2;
    var numDrafts = 0;
    var numScheduled = 0;
    var waiter = function() {
      if (--waiting == 0) {
        updateAction(numDrafts, numScheduled);
      }
    }
    db.count(function(count) {
      numDrafts = count;
      waiter();
    });
    s.count(function(count) {
      numScheduled = count;
      waiter();
    });
  }
  window.setTimeout(refreshAction, ACTION_UPDATE_INTERVAL);
})();

/**
 * Thanks Hangout Canopy team!
 */
function fetchOzData(url, callback) {
  $.ajax(url).done(function(responseText) {
    var re = /<script\b[^>]*>([\s\S]*?)<\/script>/gm;
    var matches = [];
    var match;
    var AF_initDataQueue = [];

    /*
     * Take outall the script tags
     */
    while (match = re.exec(responseText)) {
      if(match[1] && match[1].indexOf('AF_initDataQueue') > -1) {
        eval(match[1]);
      }
    }

    /*
     * Thankyou Google :)
     */
    var initDataMap = {};
    for (var i = 0; i < AF_initDataQueue.length; i++) {
      var dataPair = AF_initDataQueue[i];
      if (dataPair.key != '-1') {
        initDataMap[dataPair.key] = dataPair.data;
      }
    }
    callback(initDataMap);
  });
}

function fetchPostData(url, callback) {
  if (!url > '') {
    console.error('Url is not a string');
    return;
  }

  fetchOzData(url, function(dataMap) {
    var postData = dataMap[20];
    if (!postData) {
      console.error('Not a singleton post url');
      return;
    }

    // TODO: postData[43] has 2nd level via information which could be useful one day.
    var reshare_person_data = postData[44];

    var data = {};
    var name = postData[3];
    var id = postData[16];

    data.content = postData[4];
    data.update_id = postData[8];
    data.url = 'https://plus.google.com/' + postData[21];
    data.timeStamp = postData[5];

    if (!reshare_person_data) {
      data.author_name = name;
      data.author_id = id;
      data.author_photo_url = 'https:' + postData[18];
    } else {
      data.author_name = reshare_person_data[0];
      data.author_id = reshare_person_data[1];
      data.author_photo_url = reshare_person_data[4];
      data.via_name = name;
      data.via_id = id;
    }

    data.rawMedia = postData[11];

    callback(data);
  });
}

/**
 * callback = function(person<Array>) (see gp_editor)
 */
function profileAutocomplete(prefix, callback) {
  if (!prefix) {
    callback([]);
    return;
  }
  plus.profileAutocomplete(function(response) {
    var results = response[1];
    if (!results) {
      callback([]);
    }

    var persons = [];
    for (var i = 0; i < results.length; ++i) {
      var personObject = results[i];
      var personData = results[i][3][0];
      var person = {
        name: (personData['n'] ? personData['n'] : personObject[0]),
        id: personData['g'],
        photoUrl: 'https:' + personData['p'] + '?sz=24'
      };
      persons.push(person);
    }
    callback(persons);
  }, prefix);
}

function publishScheduled(post) {
  update();
  publish(post);
}

function publish(post, callback) {
  if (post.title) {
    post.content = '*' + post.title + '*\n\n' + post.content;
  }
  if (post.circle_ids instanceof Array) {
    post.aclItems = parseAcls(post.circle_ids);
  }
  plus.newPost(callback || c, post);
  console.log("Posting");
  console.log(post);
}

function schedule(post, callback) {
  s.schedule(post, post.timeStamp, callback);
}

function draft(post, callback) {
  db.put(post, callback);
}

function addPost(post, callback) {
  var state = post.state;
  update();

  delPost(post.writeTimeStamp, function(){});
  if (state == "scheduled") {
    schedule(post, callback);
  } else if (state == "draft") {
    draft(post, callback);
  } else if (state == "post") {
    publish(post, callback);
  } else {
    console.error('Invalid state');
    callback(false);
  }
}

function preparePost(post) {
  if (post.rawMedia) {
    post.medias = processMediaItems(post.rawMedia);
  }
  if (post.reshare && post.reshare.rawMedia) {
    post.reshare.medias = processMediaItems(post.reshare.rawMedia);
  }
  return post;
}

function fetchAll(callback) {
  if (!dbInit) {
    return;
  }
  var result = {posts: [], lastUpdate: lastUpdate};
  var parseMedia = function(result) {
    result.posts.forEach(preparePost);
    callback(result);
  };
  var wrapCallback = function() {
    s.count(function(count) {
      if (count == 0) {
        parseMedia(result);
      } else {
        s.processAllItems(function(item) {
          result.posts.push(item);
          if (--count == 0) {
            parseMedia(result);
          }
        });
      }
    });
  };
  db.count(function(count) {
    if (count == 0) {
      wrapCallback();
    } else {
      db._processAllItemsByRange(undefined, function(post) {
        post.timeStamp = undefined;
        result.posts.push(post);
        if (--count == 0) {
          wrapCallback();
        }
      });
    }
  });
}

function processMediaItems(mediaArray) {
  var result = {'images': []};
  mediaArray.forEach(function(media) {
    if (media[24][4] == "image" || media[24][4] == "photo") {
      var url = media[41][0][1];
      if (!url.match(/http/)) {
        url = 'https:' + url;
      }
      var image = {'url': url};
      result.images.push(image);
    }
    var type = media[24][3];
    if (type == "text/html" || type == "application/x-shockwave-flash") {
      result.link = {'url': media[24][1], 'title': media[3], 'description': media[21]};
    }
    if (type == "application/x-shockwave-flash") {
      result.video = {'embed': media[5][1].replace(/autoplay=1/, ''), 'w': media[5][3], 'h': media[5][2]};
    }
  });
  return result;
}

function publishDraft(writeTimeStamp, callback) {
  db.processItem(writeTimeStamp, function(post) {
    db._removeItem(writeTimeStamp, function(ok) {
      if (ok) {
        // TODO: go back to a sane state if posting failed.
        publish(post, callback);
      } else {
        console.error('Unable to remove item by key: ' + writeTimeStamp);
        callback(false);
      }
    });
  });
}

function fetchPost(writeTimeStamp, callback) {
  var race = false;
  var racer = function(item) {
    if (race) {
      // How did this happen? The assumption is that a post is is in only one of db, s.
      console.error("WTF");
      return;
    }
    race = true;
    callback(preparePost(item));
  };
  db.processItem(writeTimeStamp, racer);
  s.processItem(writeTimeStamp, racer);
}

function delPost(writeTimeStamp, callback) {
  update();
  s._removeItem(writeTimeStamp, c);
  db._removeItem(writeTimeStamp, c);
  // If you're not me and here because of a bug, I owe you a beer.
  callback(true);
}

function post(post, callback) {
    if (!post) {
      console.error('Missing request.post');
      callback(false);
      return
    }
    var state = post.state;
    if (!state) {
      console.error('Missing post.state');
      callback(false);
      return;
    }

    function postThis() {
      addPost(post, callback);
    }

    // If reshare, don't waste time on fetching media links.
    if (post.reshare) {
      postThis();
      return;
    }

    if (post.link) {
      getLinkMedia(post.link, function(data) {
        if (data) {
          post.rawMedia = data;
        }
        postThis();
      });
    } else if (post.image_id) {
      plus.fetchPhotoMetadata(function(response) {
        if (response.error || !response.data) {
          console.error(response);
          callback(false);
        } else {
          post.rawMedia = [plus._createPicasaImageItem(response.data)];
          postThis();
        }
      }, post.image_id);
    } else {
      postThis();
    }
}

function getLinkMedia(link, callback) {
  if (!link) {
    console.error('invalid link');
    return;
  }
  plus.fetchLinkMedia(function(response) {
    if (!response.status) {
      console.error('Error fetching media for ' + link);
    }
    if (response.data) {
      callback(response.data);
    }
  }, link);
}

function newPost(post) {
  // Set temporary values and open the frontend. Expect frontend to clear these from LS.
  localStorage['_tmp_post'] = JSON.stringify(preparePost(post));
  chrome.tabs.create({'url': chrome.extension.getURL('main.html')}, c);
}

function resharePost(url) {
  fetchPostData(url, function(data) {
    var post = {reshare: data,
                share_id: data.update_id,
                writeTimeStamp: new Date().getTime()};
    newPost(post);
  });
}

function parseAcls(ids) {
  if (!(ids instanceof Array)) {
    return;
  }
  return ids.map(function(id) {
    if (id == 'PUBLIC') {
      return {type: GooglePlusAPI.AclType.PUBLIC};
    } else if (id == 'EXTENDED_CIRCLES') {
      return {type: GooglePlusAPI.AclType.EXTENDED_CIRCLES};
    } else if (id == 'YOUR_CIRCLES') {
      return {type: GooglePlusAPI.AclType.YOUR_CIRCLES};
    } else {
      return {
        type: GooglePlusAPI.AclType.SPECIFIED_CIRCLE,
        id: id
      }
    }
  });
}

function onRequest(request, sender, callback) {
  var type = request.type;
  if (type == "post") {
    post(request.post, callback);
  } else if (type == "fetchAll") {
    fetchAll(callback);
  } else if (type == "delPost") {
    delPost(request.writeTimeStamp, callback);
  } else if (type == "publishDraft") {
    var writeTimeStamp = request.writeTimeStamp;
    if (!writeTimeStamp) {
      console.error("Invalid request.writeTimeStamp");
      callback(false);
    } else {
      publishDraft(writeTimeStamp, callback);
    }
  } else if (type == "fetchPost") {
    fetchPost(request.writeTimeStamp, callback);
  } else if (type == "newPost") {
    newPost({content: request.content || '',
             link: request.link || '',
             image_id: request.image_id || '',
             writeTimeStamp: new Date().getTime()});
  } else if (type == "resharePost") {
    resharePost(request.url);
  } else if (type == 'getId') {
    if (!plus.isAuthenticated()) {
      plus.init(c);
    }
    var info = plus.getInfo();
    if (plus.isAuthenticated() && info) {
      callback({'id': plus.getInfo().id});
    } else {
      callback({})
    }
  } else if (type == 'profileAutocomplete') {
    profileAutocomplete(request.prefix, callback);
  } else if (type == 'getLinkMedia') {
    getLinkMedia(request.link, function(rawMedia) {
      callback(processMediaItems(rawMedia));
    });
  } else if (type == 'getCircles') {
    plus.getCircles(function(response) {
      if (response.status) {
        callback(response.data);
      }
    });
  }
}

chrome.extension.onRequest.addListener(onRequest);
chrome.browserAction.onClicked.addListener(function() {
  newPost('', '');
});

</script>
